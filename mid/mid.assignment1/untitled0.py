# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uUycsI4YkfN5h8GdUz9IvK1lPpSI9qHf
"""

import numpy as np
import pandas as pd
import os
from sklearn.model_selection import KFold
from sklearn.metrics import accuracy_score
import cv2
import matplotlib.pyplot as plt
from collections import Counter

"""load dataset"""

from google.colab import drive

drive.mount('/content/drive')

import pandas as pd

DATA_DIR=('/content/drive/MyDrive/Animals')

def load_image(DATA_DIR):
  catagories=os.listdir(DATA_DIR)
  return catagories

"""Convert into gray scale"""

def load_images_and_labels(data_dir, target_size=(64, 64)):
    data, labels = [], []
    categories = os.listdir(data_dir)
    for category in categories:
        category_path = os.path.join(data_dir, category)
        label = categories.index(category)
        for file_name in os.listdir(category_path):
            file_path = os.path.join(category_path, file_name)
            try:
                img = cv2.imread(file_path, cv2.IMREAD_GRAYSCALE)  # Convert to grayscale
                img = cv2.resize(img, target_size)
                data.append(img.flatten())  # Flatten image for k-NN
                labels.append(label)
            except Exception as e:
                print(f"Error loading image {file_path}: {e}")
    return np.array(data), np.array(labels)

images, labels = load_images_and_labels(DATA_DIR)
print("Data loaded successfully!")
print(f"Image Shape: {images.shape}, Labels Shape: {labels.shape}")

"""Calculate Euclidean Distance"""

def euclidean_distance(x, y):
    return np.sqrt(np.sum((x - y) ** 2))

"""k-NN classifier function"""

def knn_predict(test_sample, train_data, train_labels, k):
    distances = [euclidean_distance(test_sample, x) for x in train_data]
    k_neighbors = np.argsort(distances)[:k]
    k_neighbor_labels = [train_labels[i] for i in k_neighbors]
    most_common = Counter(k_neighbor_labels).most_common(1)
    return most_common[0][0]

"""k-Fold Cross Validation and Accuracy Calculation"""

def knn_cross_validation(X, y, k_values):
    kf = KFold(n_splits=5)
    avg_accuracies = []

    for k in k_values:
        fold_accuracies = []

        for train_index, val_index in kf.split(X):
            X_train, X_val = X[train_index], X[val_index]
            y_train, y_val = y[train_index], y[val_index]

            correct_predictions = 0
            for i, test_sample in enumerate(X_val):
                prediction = knn_predict(test_sample, X_train, y_train, k)
                if prediction == y_val[i]:
                    correct_predictions += 1

            fold_accuracy = correct_predictions / len(y_val)
            fold_accuracies.append(fold_accuracy)

        avg_accuracy = np.mean(fold_accuracies)
        avg_accuracies.append(avg_accuracy)

    return avg_accuracies
def knn_cross_validation(X, y, k_values):
    kf = KFold(n_splits=5)
    avg_accuracies = []

    for k in k_values:
        fold_accuracies = []

        for train_index, val_index in kf.split(X):
            X_train, X_val = X[train_index], X[val_index]
            y_train, y_val = y[train_index], y[val_index]

            correct_predictions = 0
            for i, test_sample in enumerate(X_val):
                prediction = knn_predict(test_sample, X_train, y_train, k)
                if prediction == y_val[i]:
                    correct_predictions += 1

            fold_accuracy = correct_predictions / len(y_val)
            fold_accuracies.append(fold_accuracy)

        avg_accuracy = np.mean(fold_accuracies)
        avg_accuracies.append(avg_accuracy)

    return avg_accuracies

"""Run k-NN Cross-validation"""

k_values = [1, 3, 5, 7, 9]  # Test different k values
avg_accuracies = knn_cross_validation(images, labels, k_values)

"""Result"""

for k, accuracy in zip(k_values, avg_accuracies):
    print(f"Average accuracy for k={k}: {accuracy:.4f}")

# Optionally, plot the results
plt.plot(k_values, avg_accuracies, marker='o')
plt.title('k-NN Cross-Validation Accuracy for Different k Values')
plt.xlabel('k (Number of Neighbors)')
plt.ylabel('Average Accuracy')
plt.grid(True)
plt.show()